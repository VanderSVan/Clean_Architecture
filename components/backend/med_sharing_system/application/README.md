# Application
**Данный слой хранит в себе бизнес-логику проекта.**  
И по сути держится на двух столпах - это [**СУЩНОСТИ**](#entities) и [**СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ**](#services-или-use-cases)

---
## Навигация по слою
- [Частые вопросы](#частые-вопросы)
- [Entities](#entities)
- [Services или Use Cases](#services-или-use-cases)
- [Interfaces](#interfaces)
- [Data Transfer Objects (DTO)](#data-transfer-objects)
- [Schemas](#schemas)
- [Errors](#errors)
- [Навигация по backend](../../README.md#навигация-по-backend)

---
## Частые вопросы:

### Как понять что является бизнес-логикой?
**Идеальный сценарий**: 
Бизнес-логика может быть описана/оцифрована с помощью абстракций, сущностей, интерфейсов и не привязана к конкретным техническим зависимостям.

**Реальный сценарий**: 
В некоторых проектах ядро может опираться на конкретную зависимость, без которой невозможно описать бизнес-процессы. Например, проекты, использующие библиотеку [**pandas**](https://pandas.pydata.org/docs/), могут включать её в слой **application** или даже в **domain слой**, если вся логика строится вокруг работы с `DataFrame`.

### Почему стремятся к максимальной изоляции при оцифровке бизнес-логики?
Бизнес-логика должна описывать/оцифровывать процессы бизнеса.
В идеале она не должна зависеть от инфраструктуры или какой-либо другой внешней среды, чтобы оставаться устойчивой к изменениям и легко тестироваться.
1. **Независимость от инфраструктуры**: **Application** слой должен быть независимым от внешних факторов, таких как база данных, фреймворки или пользовательский интерфейс.
При возникновении "черных лебедей" (санкции, апокалипсис) гораздо легче произвести замену, по сравнению с системой, в которой высокая связанность компонентов.  
2. **Чистота бизнес-логики**: Изоляция позволяет сосредоточиться на описании бизнес-процессов без учета технических деталей реализации.
3. **Упрощение тестирования**: Изолированные **domain** и **application** слои легче покрыть модульными тестами.
4. **Гибкость и масштабируемость**: Изолированную бизнес-логику проще изменять и расширять без влияния на другие части системы.
5. **Повторное использование**: Хорошо изолированные **domain** и **application** слои можно использовать в разных проектах или контекстах.

### Почему избегают изоляции бизнес-логики?
1. **Дополнительные абстракции**: Требуется создавать дополнительные абстракции, что усложняет код.
2. **Время на разработку**: Правильное проектирование изолированного **domain** и **application** слоев может занять больше времени на начальных этапах.
3. **Сложность в интеграции**: Могут возникать трудности при интеграции изолированных слоев с внешними зависимостями.

[К навигации по слою](#навигация-по-слою)

---
## [Entities](./entities.py)
Это часть **Domain** слоя гексагональной архитектуры. В случае объемной бизнес-логики этот слой, как правило, выносится в отдельную директорию `domain`. В данном проекте бизнес-логика есть, но не столь объемная, поэтому она умещается в одном модуле [entities.py](./entities.py).

### Что такое сущность?

**Сущность** - это фундаментальный элемент бизнес-логики в чистом виде. Это объект, который представляет ключевые концепции и правила предметной области.

### Ключевые характеристики сущностей:

1. **Бизнес-данные и правила**: Сущность объединяет в себе данные и правила, относящиеся к конкретному бизнес-объекту.
2. **Независимость**: Сущность обособлена от деталей реализации и самостоятельна. Она не зависит от способа хранения данных или внешних систем.
3. **Идентичность**: Каждая сущность имеет уникальную идентичность, которая остается неизменной на протяжении всего жизненного цикла объекта.
4. **Инкапсуляция бизнес-правил**: Сущность содержит критические бизнес-правила в себе или имеет прямой доступ к ним.
5. **Неизменность**: Многие сущности проектируются как неизменяемые объекты, что повышает их надежность и предсказуемость.

### Отличия сущностей от Services (Use Cases):
1. **Уровень абстракции**: Сущности представляют базовые концепции домена, в то время как Use Cases описывают конкретные сценарии использования этих концепций.
2. **Область ответственности**: Сущности отвечают за правила и состояния отдельных бизнес-объектов, а Use Cases координируют взаимодействие между различными сущностями и внешними системами.
3. **Зависимости**: Сущности не должны зависеть от внешних систем или инфраструктуры, тогда как Use Cases могут взаимодействовать с различными слоями приложения.
4. **Жизненный цикл**: Сущности обычно имеют длительный жизненный цикл и могут существовать в разных контекстах, а Use Cases обычно представляют конкретные операции или процессы.
5. **Изменчивость**: Сущности редко меняются, так как они представляют стабильные концепции домена. Use Cases могут меняться чаще в ответ на изменения требований пользователей.

### Примеры сущностей:
- В банковской системе: `Account`, `Transaction`, `Customer`
- В системе электронной коммерции: `Product`, `Order`, `User`
- В системе управления проектами: `Project`, `Task`, `Employee`

### Сущности данного проекта представлены на следующей диаграмме
![entities.png](../../docs/uml_diagrams/images/entities.png)

[К навигации по слою](#навигация-по-слою)

---
## [Services или Use Cases](./services)

### Определение и назначение
**Services** оперируют сущностями и предоставляют интерфейсы для взаимодействия с инфраструктурой.
Их основное назначение - оркестрация бизнес-логики в виде реализации сценариев бизнес-логики.
Как правило, Services включают в себя все оцифрованные бизнес-процессы.

### Ключевые характеристики
1. **Оркестрация бизнес-логики**: **Services** координируют работу различных компонентов **domain** слоя для выполнения конкретных бизнес-операций.
2. **Независимость от инфраструктуры**: Хотя **services** знают о существовании инфраструктуры, они не должны зависеть от конкретных реализаций.
3. **Использование абстракций**: **Services** работают с абстракциями (интерфейсами) для взаимодействия с внешними системами, что обеспечивает гибкость и тестируемость.
4. **Транзакционное управление**: **Services** часто отвечают за управление транзакциями, особенно когда операция затрагивает несколько сущностей или репозиториев.

### Роль в архитектуре
1. **Связующее звено**: **Services** соединяют инфраструктуру (контроллеры, базы данных) с domain слоем, обеспечивая чистоту бизнес-логики.
2. **Контекст выполнения**: Определяют, какие бизнес-правила должны быть применены в каждом конкретном сценарии.
3. **Управление потоком данных**: Отвечают за получение данных из внешних источников, их обработку и передачу результатов обратно.
4. **Абстракция сложности**: Скрывают сложность взаимодействия различных компонентов системы от клиентского кода.

### Преимущества использования Services
1. **Разделение ответственности**: Позволяет изолировать бизнес-логику от деталей реализации инфраструктуры.
2. **Улучшение тестируемости**: **Services** легко тестировать, так как они работают с абстракциями.
3. **Гибкость и расширяемость**: Упрощает добавление новых функциональностей или изменение существующих без затрагивания core бизнес-логики.
4. **Повторное использование**: **Services** могут быть использованы в различных контекстах приложения.

### Примеры Use Cases:
1. В банковской системе:
   - `TransferFunds`: Перевод средств между счетами
   - `OpenNewAccount`: Открытие нового банковского счета
   - `GenerateAccountStatement`: Формирование выписки по счету
2. В системе электронной коммерции:
   - `PlaceOrder`: Размещение нового заказа
   - `ProcessRefund`: Обработка возврата товара
   - `UpdateProductInventory`: Обновление информации о наличии товара
3. В системе управления проектами:
   - `AssignTaskToEmployee`: Назначение задачи сотруднику
   - `GenerateProjectReport`: Создание отчета по проекту
   - `UpdateProjectStatus`: Обновление статуса проекта

Каждый из этих **Use Cases** будет взаимодействовать с одной или несколькими сущностями и, возможно, с внешними сервисами для выполнения конкретного сценария использования.

### Примеры взаимодействия сущностей и Use Cases:
1. `TransferFunds`:
   - Взаимодействует с сущностями `Account` для проверки баланса и выполнения транзакции
   - Создает новую сущность `Transaction` для записи операции
   - Может взаимодействовать с внешним сервисом для проверки на мошенничество
2. `PlaceOrder`:
   - Проверяет сущность `Product` для подтверждения наличия товара
   - Создает новую сущность `Order`
   - Обновляет сущность `User` с информацией о новом заказе
   - Может взаимодействовать с платежной системой для обработки оплаты
3. `AssignTaskToEmployee`:
   - Проверяет сущности `Project` и `Task` для подтверждения существования задачи
   - Обновляет сущность `Employee`, добавляя новую задачу
   - Может отправлять уведомление через внешнюю систему оповещений

Эти примеры показывают, как **Use Cases** оркестрируют взаимодействие между различными сущностями и внешними системами для выполнения конкретных бизнес-операций, в то время как сами сущности содержат основные данные и правила предметной области.

[К навигации по слою](#навигация-по-слою)

---
## [Interfaces](./interfaces)
Интерфейсы в чистой архитектуре представляют собой абстрактные контракты,
определяющие способы взаимодействия между различными слоями приложения,
особенно между слоем приложения и внешними зависимостями.
### Роль интерфейсов
1. **Абстракция зависимостей**: Интерфейсы позволяют абстрагировать конкретные реализации внешних систем и сервисов.
2. **Инверсия зависимостей**: Обеспечивают соблюдение принципа инверсии зависимостей, позволяя слою приложения зависеть от абстракций, а не от конкретных реализаций.
3. **Гибкость и расширяемость**: Упрощают замену или добавление новых реализаций без изменения основной логики приложения.
4. **Тестируемость**: Облегчают создание mock-объектов для модульного тестирования.

### Типы интерфейсов в чистой архитектуре
1. **Repository Interfaces**: Определяют методы для доступа к данным, абстрагируя детали хранения.
2. **Service Interfaces**: Описывают контракты для внешних сервисов (например, отправка email, обработка платежей).
3. **Use Case Interfaces**: Определяют контракты для конкретных сценариев использования приложения.
4. **Presenter Interfaces**: Абстрагируют логику представления данных для пользовательского интерфейса.

### Преимущества использования интерфейсов
1. **Слабая связанность**: Уменьшают зависимость между компонентами системы.
2. **Улучшенная модульность**: Позволяют легко заменять или обновлять компоненты системы.
3. **Упрощение тестирования**: Облегчают создание mock-объектов и стабов для модульного тестирования.
4. **Чистота архитектуры**: Помогают соблюдать принципы чистой архитектуры, изолируя бизнес-логику от внешних зависимостей.
5. **Гибкость при разработке**: Позволяют разным командам работать над различными частями системы независимо.

### Потенциальные недостатки и сложности

1. **Увеличение сложности**: Добавление интерфейсов может усложнить структуру проекта.
2. **Избыточность**: Чрезмерное использование интерфейсов может привести к ненужному уровню абстракции.
3. **Производительность**: Использование интерфейсов может незначительно снизить производительность.

### Практические аспекты использования интерфейсов
1. **Именование**: Обычно используют префикс "I" (например, IUserRepository) или суффикс "Port" (например, UserRepositoryPort),
либо могут и вовсе не использовать суффиксы, как в данном проекте.
В данном случае суффиксы заменены правильными импортами (`interfaces.User`, `interfaces.Repo`)
2. **Расположение**: Интерфейсы обычно располагают в отдельном пакете или директории внутри слоя приложения.
3. **Гранулярность**: Следует стремиться к правильному уровню абстракции, избегая как слишком обобщенных, так и слишком специфичных интерфейсов.
4. **Стабильность**: Интерфейсы должны быть стабильными, чтобы минимизировать влияние изменений на другие части системы.

[К навигации по слою](#навигация-по-слою)

---
## [Data Transfer Objects](./dtos)
### Определение и назначение
Data Transfer Objects (DTO) - это объекты, используемые для передачи данных между различными слоями приложения.
Они представляют собой простые структуры данных, не содержащие бизнес-логики.
Но могут содержать логику форматирования и/или валидации данных.

### Цель использования DTO в чистой архитектуре
1. **Разделение концернов**: DTO отделяют представление данных от бизнес-логики.
2. **Гибкость в передаче данных**: Позволяют передавать только необходимые данные между слоями.
3. **Изоляция слоев**: Помогают избежать утечки деталей реализации доменной модели во внешние слои.
4. **Оптимизация передачи данных**: Могут уменьшить объем передаваемых данных.

### Преимущества использования DTO:
1. **Безопасность**: Позволяют контролировать, какие данные передаются между слоями, скрывая чувствительную информацию.
2. **Версионирование API**: Упрощают изменение структуры данных API без влияния на внутренние модели.
3. **Производительность**: Могут улучшить производительность, особенно при работе с большими объемами данных или в сетевых операциях.
4. **Гибкость в представлении данных**: Позволяют адаптировать структуру данных под конкретные нужды клиента или представления.
5. **Уменьшение связанности**: Помогают избежать прямой зависимости внешних слоев от структуры доменных объектов.
6. **Упрощение тестирования**: Облегчают модульное тестирование, так как DTO легко создавать и манипулировать.

### Недостатки использования DTO:
1. **Дополнительный код**: Требуют написания дополнительного кода для создания и преобразования объектов.
2. **Дублирование структур**: Может привести к дублированию структур данных между DTO и доменными объектами.
3. **Сложность поддержки**: При частых изменениях в структуре данных требуется обновление как DTO, так и маппингов.
4. **Потенциальное снижение производительности**: В некоторых случаях может привести к снижению производительности из-за дополнительных преобразований.
5. **Увеличение сложности проекта**: Добавляет дополнительный уровень абстракции, что может усложнить понимание кода.

### Примеры использования DTO:
1. **API Responses**: Для формирования ответов API, содержащих только необходимые клиенту данные.
2. **Form Submissions**: Для обработки данных, отправленных через формы пользовательского интерфейса.
3. **Интеграция с внешними системами**: Для преобразования данных при обмене с другими системами или сервисами.

[К навигации по слою](#навигация-по-слою)

---
## [Schemas](./schemas)
Схемы запросов - это структуры данных, используемые для определения параметров фильтрации, сортировки и пагинации при запросе данных. Они представляют собой специализированную форму DTO, ориентированную на описание условий поиска и фильтрации сущностей.

### Роль схем запросов
1. **Стандартизация запросов**: Обеспечивают единый формат для передачи параметров запроса через различные слои приложения.
2. **Валидация входных данных**: Позволяют централизованно определять правила валидации для параметров запроса.
3. **Улучшение читаемости кода**: Группируют связанные параметры запроса в единую структуру.
4. **Упрощение API**: Позволяют передавать множество параметров как единый объект.

### Преимущества использования схем запросов
1. **Типобезопасность**: Есть возможность обеспечить строгую типизацию параметров запроса, что уменьшит вероятность ошибок.
2. **Повторное использование**: Схемы могут быть использованы на разных уровнях приложения - от API до репозитория.
3. **Гибкость / Легкость поддержки**: Легко расширяются для поддержки новых параметров фильтрации или сортировки.
4. **Документация**: Служат самодокументирующимся описанием возможных параметров запроса.
5. **Разделение ответственности**: Отделяют логику валидации и преобразования параметров от бизнес-логики.
6. **Улучшение тестируемости**: Упрощают написание тестов для различных сценариев фильтрации и сортировки.

### Недостатки и потенциальные проблемы
1. **Дополнительный слой абстракции**: Может усложнить структуру проекта, особенно в небольших приложениях.
2. **Потенциальное дублирование**: Может привести к дублированию кода между схемами и моделями домена.
3. **Производительность**: В некоторых случаях может привести к небольшому снижению производительности из-за дополнительных преобразований.
4. **Сложность при сложных запросах**: Может быть трудно представить очень сложные условия фильтрации в виде плоской структуры.

### Практические аспекты использования схем запросов
1. **Именование**: Обычно используют суффиксы вроде "Filter", "Params", "Query" или "Criteria" (например, `UserFilter`, `BookQuery`).
Либо могут и вовсе не использовать суффиксы, как в данном проекте.
В данном случае суффиксы заменены правильными импортами (`schemas.FindMedicalBooks`, `schemas.FindItems`).
2. **Валидация**: Использование декораторов или методов валидации для обеспечения корректности входных данных.
3. **Значения по умолчанию**: Определение разумных значений по умолчанию для необязательных параметров.
4. **Преобразование типов**: Реализация методов для преобразования входных данных в формат, удобный для использования в запросах.

### Пример использования
```python
# В слое API
@app.get("/medical-books")
async def get_medical_books(query: FindMedicalBooks):
    return await medical_book_service.find(query)

# В сервисном слое
async def find(self, query: FindMedicalBooks) -> List[MedicalBook]:
    return await self.repository.find(query)

# В репозитории
async def find(self, query: FindMedicalBooks) -> List[MedicalBook]:
    # Построение SQL-запроса на основе параметров query
    # ...
```

[К навигации по слою](#навигация-по-слою)

---
## [Errors](./errors)
Слой errors в чистой архитектуре предназначен для централизованного определения и управления ошибками, которые могут возникнуть в процессе работы приложения.
Этот слой играет ключевую роль в обеспечении согласованной обработки исключений и предоставлении информативных сообщений об ошибках.

### Роль слоя errors
1. **Стандартизация ошибок**: Обеспечивает единый подход к определению и обработке ошибок во всем приложении.
2. **Изоляция бизнес-ошибок**: Отделяет ошибки, связанные с бизнес-логикой, от системных или инфраструктурных ошибок.
3. **Улучшение отладки**: Предоставляет детальную информацию об ошибках, облегчая процесс отладки.
4. **Повышение безопасности**: Помогает контролировать, какая информация об ошибках доступна внешним пользователям.

### Типы ошибок в слое Application
1. **Бизнес-ошибки**: Связаны с нарушением бизнес-правил или логики (например, `InsufficientFundsError`).
2. **Ошибки валидации**: Возникают при некорректных входных данных (например, `InvalidInputError`).
3. **Ошибки доступа**: Связаны с проблемами авторизации или аутентификации (например, `UnauthorizedAccessError`).
4. **Ошибки состояния**: Возникают при попытке выполнить операцию в недопустимом состоянии (например, `InvalidStateError`).
5. **Ошибки внешних сервисов**: Связаны с проблемами при взаимодействии с внешними системами (например, `ExternalServiceUnavailableError`).

### Преимущества использования слоя errors
1. **Консистентность**: Обеспечивает единообразный подход к обработке ошибок во всем приложении.
2. **Улучшенная читаемость**: Централизованное определение ошибок упрощает понимание возможных исключительных ситуаций.
3. **Упрощение обработки**: Позволяет легко идентифицировать и обрабатывать различные типы ошибок на разных уровнях приложения.
4. **Гибкость в предоставлении информации**: Можно легко контролировать, какая информация об ошибках доступна для разных типов пользователей.
5. **Улучшение логирования**: Облегчает процесс логирования ошибок и их анализа.

### Практические аспекты реализации
1. **Иерархия ошибок**: Создание иерархии классов ошибок для более эффективной категоризации и обработки.
2. **Информативные сообщения**: Включение полезной информации в сообщения об ошибках для облегчения отладки.
3. **Локализация**: Поддержка многоязычных сообщений об ошибках для интернационализации приложения.
4. **Кодирование ошибок**: Присвоение уникальных кодов ошибкам для облегчения их идентификации и документирования.
5. **Безопасность**: Обеспечение, чтобы чувствительная информация не раскрывалась в сообщениях об ошибках.

### Пример реализации

```python
from typing import Optional

class ApplicationError(Exception):
    """Базовый класс для всех ошибок приложения"""
    def __init__(self, message: str, code: str, details: Optional[dict] = None):
        self.message = message
        self.code = code
        self.details = details
        super().__init__(self.message)

class BusinessLogicError(ApplicationError):
    """Базовый класс для ошибок бизнес-логики"""
    pass

class ValidationError(ApplicationError):
    """Ошибка валидации входных данных"""
    pass

class InsufficientFundsError(BusinessLogicError):
    """Ошибка недостаточности средств"""
    def __init__(self, account_id: int, required_amount: float, available_amount: float):
        super().__init__(
            message="Insufficient funds for the operation",
            code="INSUFFICIENT_FUNDS",
            details={
                "account_id": account_id,
                "required_amount": required_amount,
                "available_amount": available_amount
            }
        )

# Использование:
# raise InsufficientFundsError(account_id=123, required_amount=1000, available_amount=500)
```

[К навигации по слою](#навигация-по-слою)
